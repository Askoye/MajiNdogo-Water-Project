-- CLUSTERING DATA TO UNVEIL MAJI NDOGO'S WATER CRISIS

-- Updating the employee's table with their respective email addresses

/*
   Email addresses are generated by converting employee names to lowercase, replacing spaces with dots,
   and appending '@ndogowater.gov'. This step enhances data organization for Maji Ndogo's water crisis analysis.
*/
UPDATE employee
SET email = CONCAT(LOWER(REPLACE(employee_name, ' ', '.')), '@ndogowater.gov');


-- Removing Trailing Whitespaces from Employee Phone Numbers

/*
   This SQL update statement removes trailing whitespaces from the phone numbers in the employee table.
   Trimming ensures uniformity in phone number formatting, improving data consistency and accuracy.
*/
UPDATE employee
SET phone_number = TRIM(phone_number);


-- Recognizing Employee Contributions by Town

/*
   This query acknowledges the efforts of workers by providing a count of employees in each town.
   It groups the employee data by town_name, calculates the number of employees in each town,
   and presents the results in descending order based on the count.
*/
SELECT
    town_name,
    COUNT(*) AS num_employees
FROM 
    employee
GROUP BY town_name
ORDER BY num_employees DESC;


-- Recognizing Top-Performing Employees Based on Visit Count

/*
   This query identifies the top 3 employees based on the visit count. It calculates the number of visits
   for each assigned employee, groups the data by employee ID, and presents the results in descending order
   to highlight the top performers.
*/
SELECT 
    assigned_employee_id,
    COUNT(*) AS number_of_visits
FROM visits
GROUP BY assigned_employee_id
ORDER BY number_of_visits DESC
LIMIT 3;


-- Retrieving Information for Top 3 Employees

/*
   This query retrieves detailed information for the top 3 employees based on their assigned IDs.
   The selected information includes employee name, email, and phone number.
   The employee IDs (1, 30, 34) correspond to the top performers identified in a previous analysis.
*/
SELECT 
    employee_name,
    email,
    phone_number
FROM employee
WHERE assigned_employee_id IN (1, 30, 34);


-- Analyzing Locations
-- Counting Records per Town

/*
   This query analyzes the distribution of records in the location table by counting the number of records
   in each town. It provides insights into the concentration of location data within different towns.
   The results are presented in descending order, and only the top 5 towns with the highest record counts are displayed.
*/
SELECT 
    town_name,
    COUNT(*) AS number_of_records
FROM location
GROUP BY town_name
ORDER BY number_of_records DESC
LIMIT 5;


-- Analyzing Locations
-- Counting Records per Province

/*
   This query analyzes the distribution of records in the location table by counting the number of records
   in each province. It provides insights into the concentration of location data within different provinces.
   The results are presented in descending order, and only the top 5 provinces with the highest record counts are displayed.
*/
SELECT 
    province_name,
    COUNT(*) AS number_of_records
FROM location
GROUP BY province_name
ORDER BY number_of_records DESC
LIMIT 5;


-- Analyzing Locations
-- Counting Records per Province and Town

/*
   This query analyzes the distribution of records in the location table by counting the number of records
   for each combination of province and town. It provides detailed insights into the distribution of location data
   across different provinces and towns. The results are ordered by province in ascending order and records per town in descending order,
   and only the top 5 combinations are displayed.
*/
SELECT 
    province_name,
    town_name,
    COUNT(town_name) AS records_per_town
FROM 
    location
GROUP BY province_name, town_name
ORDER BY province_name ASC, records_per_town DESC
LIMIT 5;


-- Analyzing Locations
-- Counting Records per Location Type

/*
   This query analyzes the distribution of records in the location table by counting the number of records
   for each location type. It provides insights into the prevalence of different location types in the dataset.
   The results are grouped by location type, showcasing the count of records for each type.
*/
SELECT 
    location_type,
    COUNT(*) AS num_sources
FROM
    location
GROUP BY location_type;


-- Analyzing Location Distribution
-- Expressing the Number of Records per Location in Percentages

/*
   This query calculates the percentage distribution of water sources in Maji Ndogo.
   It expresses approximately 60% of the water sources in Rural communities and 40% in Urban communities.
   The calculations are based on the counts of records in the 'location' table for Urban and Rural locations.
*/
SELECT 
    (23740 / (15910 + 23740) * 100) AS pct_urban,
    (15910 / (15910 + 23740) * 100) AS pct_rural;



-- Exploring Water Sources

-- The number of people surveyed

/*
   This query calculates the total number of people served by summing up the 'number_of_people_served' column in the 'water_source' table.
   The result provides an overview of the scale of water source coverage in Maji Ndogo.
*/
SELECT 
    SUM(number_of_people_served) AS total_num_of_people
FROM water_source;


-- Analyzing Water Sources
-- Count of Each Water Source

/*
   This query analyzes the distribution of water sources by counting the number of records
   for each type of water source. It provides insights into the prevalence of different water source types
   in the Maji Ndogo dataset. The results are grouped by the type_of_water_source and ordered in descending order by the count.
*/
SELECT
    type_of_water_source,
    COUNT(*) AS num_of_records
FROM
    water_source
GROUP BY type_of_water_source
ORDER BY num_of_records DESC;


-- Analyzing Water Source Capacity
-- Average Number of People Served per Water Source

/*
   This query calculates the average number of people served for each type of water source.
   It provides insights into the capacity of different water source types to serve the population.
   The results are grouped by type_of_water_source and ordered in descending order by the average number of people served.
*/
SELECT 
    type_of_water_source,
    ROUND(AVG(number_of_people_served), 0) AS average_num_of_people
FROM water_source
GROUP BY type_of_water_source
ORDER BY average_num_of_people DESC;


-- Analyzing Water Source Impact
-- Number of People Getting Water from Each Water Source

/*
   This query calculates the total population served and the percentage of the total population
   served by each type of water source. It provides insights into the impact of different water source types
   on the overall population. The results are grouped by type_of_water_source and ordered in descending order
   by the total population served.
*/
SELECT 
    type_of_water_source,
    SUM(number_of_people_served) AS population_served,
    ROUND(SUM(number_of_people_served / 27628140 * 100), 0) AS percentage_people_per_source
FROM water_source
GROUP BY type_of_water_source
ORDER BY population_served DESC;


-- Prioritizing Water Sources
-- Ranking Water Sources in Order of Priority

/*
   This query prioritizes water sources by ranking them based on the total population served.
   It provides insights into the relative importance of different water source types in serving the population.
   The results include the type_of_water_source, the total population served, and the rank of each source based on population.
   The ranking is determined by the descending order of the total population served.
*/
SELECT
    type_of_water_source,
    SUM(number_of_people_served) AS population_served,
    RANK() OVER(ORDER BY SUM(number_of_people_served) DESC) AS rank_population
FROM water_source
GROUP BY type_of_water_source
ORDER BY population_served DESC;


-- Prioritizing Water Sources with RANK()
-- Ranking Water Sources within Each Type

/*
   This query utilizes the RANK() function to prioritize water sources within each type.
   It provides insights into the relative importance of individual water sources within specific types
   such as 'well,' 'shared_tap,' and 'river.' The results include source_id, type_of_water_source,
   number_of_people_served, and the priority rank within each water source type.
   The ranking is determined by the descending order of the number_of_people_served within each type.
*/
SELECT
    source_id,
    type_of_water_source,
    number_of_people_served,
    RANK() OVER(PARTITION BY type_of_water_source ORDER BY number_of_people_served DESC) AS priority_rank
FROM water_source
WHERE type_of_water_source IN ('well', 'shared_tap', 'river')
ORDER BY type_of_water_source, priority_rank DESC;


-- Prioritizing Water Sources with DENSE_RANK()
-- Ranking Water Sources within Each Type

/*
   This query utilizes the DENSE_RANK() function to prioritize water sources within each type.
   It provides insights into the relative importance of individual water sources within specific types
   such as 'well,' 'shared_tap,' and 'river.' The results include source_id, type_of_water_source,
   number_of_people_served, and the priority rank within each water source type.
   The ranking is determined by the descending order of the number_of_people_served within each type.
*/
SELECT
    source_id,
    type_of_water_source,
    number_of_people_served,
    DENSE_RANK() OVER(PARTITION BY type_of_water_source ORDER BY number_of_people_served DESC) AS priority_rank
FROM water_source
WHERE type_of_water_source IN ('well', 'shared_tap', 'river')
ORDER BY type_of_water_source, priority_rank DESC;


-- Prioritizing Water Sources with ROW_NUMBER()
-- Ranking Water Sources within Each Type

/*
   This query utilizes the ROW_NUMBER() function to assign a unique priority rank to water sources within each type.
   It provides insights into the relative importance of individual water sources within specific types
   such as 'well,' 'shared_tap,' and 'river.' The results include source_id, type_of_water_source,
   number_of_people_served, and the unique priority rank within each water source type.
   The ranking is determined by the descending order of the number_of_people_served within each type.
*/
SELECT
    source_id,
    type_of_water_source,
    number_of_people_served,
    ROW_NUMBER() OVER(PARTITION BY type_of_water_source ORDER BY number_of_people_served DESC) AS priority_rank
FROM water_source
WHERE type_of_water_source IN ('well', 'shared_tap', 'river')
ORDER BY type_of_water_source, priority_rank DESC;


-- Analyzing Survey Duration

/*
   This query examines the duration of the survey conducted during visits.
   It calculates the earliest and latest dates of the survey and determines the length of the survey
   in terms of the difference in days between the first and last dates.
*/
SELECT 
    MIN(time_of_record) AS first_date,
    MAX(time_of_record) AS last_date,
    DATEDIFF(MAX(time_of_record), MIN(time_of_record)) AS Survey_length
FROM
    visits;


-- Analyzing Average Total Queue Time for Water

/*
   This query calculates the average total queue time for water by considering the time_in_queue column.
   It uses the AVG function while excluding visits with a time_in_queue of 0 to provide an accurate representation
   of the average queue time for water-related activities.
*/
SELECT
    AVG(NULLIF(time_in_queue, 0)) AS Avg_time_in_queue
FROM 
    visits;


-- Analyzing Average Queue Time on Different Days

/*
   This query calculates the average queue time for water-related activities on different days of the week.
   It uses the DAYNAME function to extract the day of the week from the time_of_record column,
   and then calculates the rounded average queue time, excluding visits with a time_in_queue of 0.
   The results are grouped by the day of the week.
*/
SELECT 
    DAYNAME(time_of_record) AS day_of_week,
    ROUND(AVG(NULLIF(time_in_queue, 0)), 0) AS avg_queue_time
FROM visits
GROUP BY DAYNAME(time_of_record);


-- Efficient Communication of Average Queue Time by Hour

/*
   This query aims to communicate information efficiently by analyzing the average queue time
   for water-related activities, grouped by the hour of the day. It uses the TIME_FORMAT function
   to extract the hour from the time_of_record column and calculates the rounded average queue time,
   excluding visits with a time_in_queue of 0. The results are ordered in descending order by the average queue time.
*/
SELECT 
    TIME_FORMAT(TIME(time_of_record), '%H:00') AS hour_of_day,
    ROUND(AVG(NULLIF(time_in_queue, 0)), 0) AS avg_queue_time
FROM visits
GROUP BY TIME_FORMAT(TIME(time_of_record), '%H:00')
ORDER BY avg_queue_time DESC;


-- Drilling Down into Average Queue Time by Hour and Day of the Week

/*
   This query drills down into the average queue time for water-related activities by hour and day of the week.
   It uses the TIME_FORMAT function to extract the hour from the time_of_record column and calculates
   the rounded average queue time for each day of the week. The results are presented in a tabular format with
   columns representing each day (Sunday to Saturday). Excludes visits with a time_in_queue of 0 for accuracy.
*/
SELECT
    TIME_FORMAT(TIME(time_of_record), '%H:00') AS hour_of_day,
    ROUND(AVG(CASE WHEN DAYNAME(time_of_record) = 'Sunday' THEN time_in_queue ELSE NULL END), 0) AS Sunday,
    ROUND(AVG(CASE WHEN DAYNAME(time_of_record) = 'Monday' THEN time_in_queue ELSE NULL END), 0) AS Monday,
    ROUND(AVG(CASE WHEN DAYNAME(time_of_record) = 'Tuesday' THEN time_in_queue ELSE NULL END), 0) AS Tuesday,
    ROUND(AVG(CASE WHEN DAYNAME(time_of_record) = 'Wednesday' THEN time_in_queue ELSE NULL END), 0) AS Wednesday,
    ROUND(AVG(CASE WHEN DAYNAME(time_of_record) = 'Thursday' THEN time_in_queue ELSE NULL END), 0) AS Thursday,
    ROUND(AVG(CASE WHEN DAYNAME(time_of_record) = 'Friday' THEN time_in_queue ELSE NULL END), 0) AS Friday,
    ROUND(AVG(CASE WHEN DAYNAME(time_of_record) = 'Saturday' THEN time_in_queue ELSE NULL END), 0) AS Saturday
FROM
    visits
WHERE
    time_in_queue != 0 -- Excludes visits with 0 queue times for accuracy
GROUP BY
    hour_of_day
ORDER BY
    hour_of_day;
